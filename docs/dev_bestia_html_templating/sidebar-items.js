initSidebarItems({"macro":[["s","short macro `s!` for &str.to_string or format!(). because that is so common. Equivalents: String::new(), x.to_string(), x.to_owned(),…"],["url_u","returns UrlUtf8EncodedString::new_x Constructor macro for UrlUtf8EncodedString The attribute [macro_export] “moves” the macro in the main module. Macros cannot be inside impl like fn. The module names must be added to the code to work properly. TODO: use macro repetition to avoid having 4 different fn."]],"mod":[["html_template_mod","html templating library for html It can work on the server and on the client (web browser in wasm). it reads through every token in the html and when finds a template variable example:  or data-wt_name=“class” or  it calculates it and replace the next token: it can be a text_node, attribute, a complex node,… On the server the placeholders start with “s” like “st_name” : st_, sb_,… On the web web browser (client) the placeholders start with “w” like “wt_name”: wt_, wb,… It is possible to use partially on the server and partially on the client. It is compatible also with `svg` where special namespaces are used."],["macros_mod",""],["url_utf8_mod","url encoding and decoding in html This module is strictly limited to utf8 urls. Url is made of parts, fragments or segments mostly delimited by slash “/”. They must be separately encoded/decoded, not as a whole string. It is impossible to guarantee that the whole string is correctly encoded/decoded. But is possible to minimize the misuse of the String type for Url. With the normal String it is not possible to force the developer to encode/decode. With special wrapper types around String is possible to help the coder to write properly and not forget about it. TODO: analyze if is possible to use more &str and Cow instead of always allocating String. But urls are usually small and this is not a priority."],["utils_mod","small utility functions"]]});